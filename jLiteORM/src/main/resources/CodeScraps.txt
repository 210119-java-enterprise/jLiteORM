 /*
    The logic from the Driver class demo by Wez
     */
//    public void placeHolderMethod(){
//
//        for (Metamodel<?> metamodel : metamodelList) {
//
//            System.out.printf("Printing metamodel for class: %s\n", metamodel.getClassName());
//            IdField idField = metamodel.getPrimaryKey();
//            List<ColumnField> columnFields = metamodel.getColumns();
//            List<ForeignKeyField> foreignKeyFields = metamodel.getForeignKeys();
//            //Not sure about this type with generics
//            TableClass<TableClass> tableField = metamodel.getTable();
//            System.out.printf("\tFound a table field of type %s, which maps to the table name: %s \n", tableField.getName(), tableField.getTableName());
//
//            System.out.printf("\tFound a primary key field named %s of type %s, which maps to the column with the name: %s\n", idField.getName(), idField.getType(), idField.getColumnName());
//
//            for (ColumnField columnField : columnFields) {
//                System.out.printf("\tFound a column field named: %s of type %s, which maps to the column with the name: %s\n", columnField.getName(), columnField.getType(), columnField.getColumnName());
//            }
//
//            for (ForeignKeyField foreignKeyField : foreignKeyFields) {
//                System.out.printf("\tFound a foreign key field named %s of type %s, which maps to the column with the name: %s\n", foreignKeyField.getName(), foreignKeyField.getType(), foreignKeyField.getColumnName());
//            }
//
//            System.out.println();
//        }
//    }


Scraps from breaking up the CRUD insert method

/*
         Gets a list of fields from metamodel/object. Requires two lists to
         get in string form. Separate into diff method
         */
        List<ColumnField> columns = metamodel.getColumns();
        List<String> columnNames = new ArrayList<>();
        for(ColumnField cf:columns){
            columnNames.add(cf.getColumnName());
        }
        /*
        Sorts the columns alphabetically, combine with above to diff method
         */
        System.out.println("Before sorting: "+ columnNames);
        Collections.sort(columnNames);
        System.out.println("After sorting: "+columnNames);

        //Print all fields/columns. Part of above method
        System.out.print("Columns in the SQL table: ");
        System.out.println(columnNames.toString());
        //columnNames.forEach(System.out::println);




              /*
                Below should be its own method for StringBuilding the SQL statement
                 */
                 /*
                Map used for connecting wildcard order location to column name
                 */
                Map<String,Integer> wcMap  = new HashMap<String,Integer>();
                Integer wildcarOrder = 0;

                /*
                StringBuilder build the SQL statement
                 */
                StringBuilder sb = new StringBuilder("INSERT INTO ");
                sb.append(tableName);
                sb.append( " (");
                for (int i = 0; i < columnNames.size(); i++) {
                    if(i==columnNames.size()-1){
                        sb.append(columnNames.get(i)+")");
                        wcMap.put(columnNames.get(i), ++wildcarOrder);
                        break;
                    }
                    sb.append(columnNames.get(i)+", ");
                    wcMap.put(columnNames.get(i), ++wildcarOrder);
                }
                sb.append( " VALUES ");
                sb.append("(");
                for (int i = 0; i < columnNames.size(); i++){

                    if(i==columnNames.size()-1){
                        sb.append("?)");
                        break;
                    }
                    sb.append("?, ");
                }

                //Prints StringBuilder sql statement
                System.out.println("Generated SQL statement: "+ sb);


                //Prints the column names and their wildcard order)
                System.out.println("Columns and their wildcard positions: "+wcMap.toString());



                  Map<String, Object> sorted = objValues
                                .entrySet()
                                .stream()
                                .sorted(comparingByKey())
                                .collect(toMap(e -> e.getKey(), e -> e.getValue(), (e1, e2) -> e2, LinkedHashMap::new));

                        System.out.println("map after sorting by keys: " + sorted);


   //Breaks if I change the name of the Getter annotation

        /*
        Move on to integrating those values into the SQL statement
         */

        /*
        Try using a connection from the current Session object
         */

        //May want to pull this connection instance from somewhere else, where it already exists


               pstmt.setString(1, newObj.getUsername());
        //            pstmt.setString(2, newObj.getPassword());
        //            pstmt.setString(3, newObj.getFirstName());
        //            pstmt.setString(4, newObj.getLastName());


          //System.out.println("Name of the SQL table: " + tableName);
          //System.out.println(columnNames);
          //System.out.println("Name of the primary key: " + primaryKey);
           //System.out.println(objValues.toString());
            //System.out.println("map after sorting by keys: " + sortedMap);
              //System.out.println("SQL statemet: " + sqlString);

               System.out.println("Trying to verify that it worked");
                                      method = metamodel.getClazz().getMethod("getId");
                                      Object returnValue = method.invoke(obj);
                                      System.out.println("Did it work, setting value of object: "+returnValue.toString());


               //Try with resources
                       //(Connection conn = ConnectionFactory.getInstance().getConnection())

                      //Should reuse connections, original was not try with resources
                              //(Connection conn = ConnectionFactory.getInstance().getConnection())



//                for(String s : rsColumns){
//
//                    //How to get the column's class?
//
//                    //Class<?> type = metamodel.findClassOfColumn(s);
//                    //Class<?> type = Object.class;
//
//                    Object objectValue = rs.getObject(s);
//
//                    //How to get the field name of column
//                    //String name = metamodel.findFieldNameOfColumn(s);
//
//                    //String methodName = name.substring(0,1).toUpperCase() + name.substring(1);
//
//                    //Ultimately want to do this
//                    Method method = obj.getClass().getMethod("set" + methodName, type);
//                    method.invoke(newObject, objectValue);
//                }